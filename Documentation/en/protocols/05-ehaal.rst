..  IVXV protocols

===================
Electronic Vote
===================

The IVXV voting protocol is based on the double envelope system, which means
that the voter’s true plaintext intent is encrypted with the public key issued
by the organizer of the election. The encrypted intent is signed digitally with
signing means available to the voter, and delivered to the collector service in
an agreed upon container format. The collector service may additionally qualify
the vote signed by the voter, for example by making sure that the signing
certificate is valid. The IVXV protocol suite requires, among other things, that
the votes received by the collector service be registered in an external
registration service.

The vote stored by the collector service along with its qualifying elements are
made available to both the voter application and the verification application,
which perform the same checks on a single vote that are later performed on all
votes by the processing application of the election organizer.  The option to
check qualifying elements gives the voter confidence that their voice can be
processed properly in the later stages.


Voter’s Plaintext Intent
============================

The voter’s plaintext intent exists in the voter application and later also in
the verification application. The voter’s intent includes the code of the choice
in the district, the EHAK code of the district, the name of the choice list, and
the name of the specific choice in the list.

.. code-block:: bnf

    choice-name = 1*100UTF-8-CHAR
    choicelist-name = 1*100UTF-8-CHAR

    ballot = district-choice '\x1F' choicelist-name '\x1F' choice-name


Encrypted Ballot
==================

The voter’s intent in the form of a plaintext :token:`ballot` is encrypted by
the voter application using the public key generated by the election organizer.
For encryption, IVXV needs a non-deterministic, homomorphic public key
cryptosystem.  The ElGamal cryptosystem is good for that purpose; it is now used
in the IVXV context for a residue class set.

The public key of ElGamal is encoded with the ElGamal cryptosystem parameters
and the identifier that characterizes the specific election. The cryptosystem
parameters are part of the algorithm identifier structure, the public key is
encoded into the :token:`SubjectPublicKeyInfo` structure.

::

    elGamalEncryption OBJECT IDENTIFIER ::= {
        {iso(1) org(3) dod(6) internet(1) private(4) enterprise(1) dds(3029) asymmetric-encryption(2) 1}
    }

    elGamal-Params-IVXV ::= SEQUENCE {
        p                   INTEGER,
        g                   INTEGER,
        election-identifier GeneralString
    }

    elGamalPublicKey ::= SEQUENCE {
        y           INTEGER,
    }

    SubjectPublicKeyInfo ::= SEQUENCE {
        algorithm   AlgorithmIdentifier,
        subjectPublicKey    BIT STRING
    }


In order to encrypt the voter’s intent, the UTF-8 encoded data structure
:token:`ballot` is taken and converted into an element in a set specified by the
ElGamal parameters. We presume the parameter :token:`p` to be 256 bytes.  In
that case, the length of the structure :token:`ballot` can be 253 bytes. The
plaintext intent is padded to match the length of the parameter :token:`p`.

.. code-block:: bnf

    padded-ballot = ballot '\x00' '\x01' *'\xff' '\x00'


The padded intent is interpreted as an integer, encoded as a quadratic residue
in the set specified by parameter  :token:`p`.  Encoding is bijective and
important for the further mixing of the ciphertext.

The intent is encrypted pursuant to the ElGamal method with a public key.

::

    elGamalEncryptedMessage ::= SEQUENCE {
        a           INTEGER,
        b           INTEGER
    }

    encryptedBallot ::= SEQUENCE {
        algorithm   AlgorithmIdentifier,
        cipher  ANY
    }


The DER encoding of the data structure :token:`encryptedBallot` is an encrypted
ballot i.e. the inner envelope in the double envelope system.

In the course of encrypting the voter's intent, the voter application generates a random
number used by the ElGamal for encryption. The same random number is later
revealed to the verification application. Pursuant to the idiosyncrasy of the
ElGamal cryptosystem, this random number functions as a so-called second key and
allows for the decoding of the ciphertext in the verification application.


Vote Signed by the Voter
================================

Before it is sent to be stored by the collector service, the encrypted ballot
has to be signed digitally, which can be done using all the digital signing
means valid in the Republic of Estonia: the ID card, digital ID, and mobile ID.

This specification foresees using the BDOC signature format defined in the
Republic of Estonia Draft Standard [BDOC2.1]. The BDOC signature format is made
up of the ETSI standard TS 101 903 (XadES) profile and the OpenDocument
container format. The IVXV protocol suite also allows using alternative
signature and container formats.

Depending on the number of questions posed at the current election, a digitally
signed vote can contain one or several data files with the MIME type
``application/octet-stream``. Each data file contains an encrypted ballot. To hash
the data file and the other data objects to be signed before signing, the hash
function SHA-256 is used. The name of the data file is made up of the extension
``ballot`` and the election and question identifiers. All referenced data files
have to be included in the signature container. A digitally signed vote cannot
contain data files other than those which include votes cast in the context of
the ongoing election. The collector service has to refuse to accept, store and
process votes that to not match the settings.


.. code-block:: bnf

    extension = "ballot"

    encrypted-ballot-name = election-identifier '.' question-identifier '.' extension


The vote signed by the voter in the voter application is generated so that it
could be further qualified in the collector service. This specification foresees
getting both the OCSP validity certification and the PKIX timestamp to qualify a
vote. This means that the final qualified vote is in the BDOC-TS format.

If a vote is signed using an ID card or digital ID, then the original signed
container is generated in the voter application. If the vote is signed with
mobile ID, the container is generated in cooperation between the voter
application and the DigiDoc service relayed by the collector service. In case of
mobile ID, the collector service uses the DigiDoc service only to get a
signature for the encrypted ballot.  All elements necessary to qualify a vote
are requested from relevant services only when the voter application has sent a
signed vote to be stored. The qualified vote is delivered by the collector
service to the voter application for verification, only a qualified vote has to
meet the requirements of the BDOC 2.1 standard – the vote generated by the voter
application is an intermediate step in reaching a qualified vote.

A vote signed in the voter application can only have one signature, which is
kept in the signature file ``META-INF/signature0.xml``. The container containing the
vote and the signature is generated using the method specified in the BDOC 2.1
standard.

Below is a specification for a single-question vote signed in the voter
application.

For the hash algorithm ``DIGEST_ALG``, the SHA-256
(http://www.w3.org/2001/04/xmlenc#sha256) is used. To canonicalize XML
(``CANON_ALG``), the method c14n11 (http://www.w3.org/2006/12/xml-c14n11) is used.

In case of RSA keys (ID card, digital ID), the signing method is
http://www.w3.org/2001/04/xmldsig-more#rsa-sha256. In case of ECC keys (mobile
ID), it is http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256.

The exact value of the identifiers `VOTE_REF`, `SP_URI` ning `SV_URI` is not
important.

Element `SignedProperties`
---------------------------

The element ``SignedProperties`` is generated according to the BDOC 2.1 standard.
If a timestamp is used for qualification, then the element
``SignaturePolicyIdentifier`` is not used. No non-obligatory elements are used.
The time of signing is fixed by the computer filling in the data structure, and
the voter’s X509 certificate is retrieved from the ID card or using the DigiDoc service.


.. literalinclude:: ../../common/xmltemplates/sp.template
   :language: xml
   :linenos:


Element `SignedInfo`
---------------------

The element ``SignedInfo`` is generated according to the BDOC 2.1 standard,
referring to both the encrypted ballot (``VOTE_DIGEST``) and the element
``SignedProperties`` (``SP_DIGEST``).

.. literalinclude:: ../../common/xmltemplates/si.template
   :language: xml
   :linenos:


Element `SignatureValue`
------------------------

The element ``SignatureValue`` is generated according to the BDOC 2.1 standard.
The canonicalized element ``SignedInfo`` is the basis for calculating the hash,
which is signed using the PKCS1 method.

.. literalinclude:: ../../common/xmltemplates/sv.template
   :language: xml
   :linenos:


Element `XAdESSignatures`
-------------------------

The element ``XAdESSignatures`` contains one ``Signature`` element, generated on the
basis of all the previous elements and the voter’s X509 certificate. The element
``UnsignedProperties`` is not used.

.. literalinclude:: ../../common/xmltemplates/sig.template
   :language: xml
   :linenos:
