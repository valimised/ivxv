#!/bin/bash
# import: import statement generator for IVXV modules.
#
# import currently assumes that all sub-packages of a package are its modules.
# If this changes, then we need to start parsing Go source code to determine
# the list of modules.

set -e

# We have quite a lot of unquoted variables in this script: this is
# intentional, as we want to split output of commands and functions. However we
# only want to do this on newlines and not spaces, so override IFS.
IFS="
"

directive="//ivxv:modules"
development="//ivxv:development"
importfile="gen_import.go"
developmentfile="gen_import_dev.go"

usage () {
	cat <<HERE
usage: $0 [-vh] [<package>...]

We use a registration-based approach for IVXV package modules, which means that
when they are imported, they register themselves in their parent package
(similar to what the "crypto" package does with hashes). This way the main
binary can control which implementations are linked and the parent package
dispatches to the implementations.

import helps out by creating an import statement for all modules of a package.
It takes a list of packages as input and searches files in those packages for
the string "$directive". If found, it generates imports for all submodules
of ivxv.ee packages listed after that string under a separate file.

For example, if invoked as "import ivxv.ee/service/...", it will look through
all service packages and if it finds "$directive auth" in a file, it
creates a new file under that package which imports all submodules of
ivxv.ee/auth.

If a submodule contains the string "$development", then it is considered
a development-only submodule. These submodules will be put in a separate file
from other imports and have the "development" build constraint set, i.e., those
modules will only be imported if the binary is built with the "development"
build tag.
HERE
}

verbose="false"
while getopts ":hv" opt; do
	case "$opt" in
		"h")
			usage
			exit 0
			;;
		"v")
			verbose="true"
			;;
		"?")
			echo "error: unknown option -$OPTARG" >&2
			usage
			exit 1
			;;
	esac
done
shift $((OPTIND-1))

# find_directive greps through all directories given as arguments looking for
# the directive and prints any packages listed in such directives.
find_directive () {
	# We need to declare the local variable beforehand, because local
	# always returns 0.

	local directives
	for dir in "$@"; do
		# Disable exiting on errors to check grep return value.
		set +e
		directives=$(grep -hd skip "$directive" "$dir"/*)
		rc=$?
		case $rc in
			[0-1])
				# Expected return values.
				;;
			*)
				exit $rc
				;;
		esac
		set -e
		echo "$directives" | sed -n "s;.*$directive \\(.*\\);\\1;p"
	done
}

# list_modules prints a string of the form "importpath:dir" for each subpackage
# of the IVXV Go packages given as arguments.
list_modules () {
	# Use a local variable instead of piping go into grep so that this
	# function fails if go fails.

	local modules
	for parent in "$@"; do
		modules=$(${GO:-go} list -f '{{.ImportPath}}:{{.Dir}}' "ivxv.ee/$parent/...")
		echo "$modules" | grep -v "^ivxv.ee/$parent:"
	done
}

# dev_modules takes a boolean argument and a list of Go package of the form
# "importpath:dir". It prints the import paths of all Go packages that contain
# the development directive somewhere in their source code. If the boolean
# value is false, then it prints the import paths of packages which do not have
# the development directive instead.
dev_modules () {
	local greprc=0
	if [ "$1" = "false" ]; then
		greprc=1
	fi
	shift 1

	local import
	local dir
	for pkg in "$@"; do
		import=$(echo "$pkg" | cut -d: -f 1)
		dir=$(echo "$pkg" | cut -d: -f 2)

		# Disable exiting on errors to check grep return value.
		set +e
		grep -hd skip "$development" "$dir"/* > /dev/null
		rc=$?
		case $rc in
			[0-1])
				if [ $rc -eq $greprc ]; then
					echo "$import"
				fi
				;;
			*)
				exit $rc
				;;
		esac
		set -e
	done
}

# create_import takes a file path, a package name, a boolean, and a list of
# modules as arguments. It creates a Go source file at the path with the
# provided package name which imports all of the listed modules. If the boolean
# value is true, then it adds a "development" build constraint to the source
# file.
#
# If no modules are given, then the file is not created.
create_import () {
	local path="$1"
	local name="$2"
	local dev="$3"
	shift 3

	# Do not create empty file.
	if [ $# -eq 0 ]; then
		return 0
	fi

	cat > "$path" <<HERE
// Generated by ivxv.ee/cmd/import. DO NOT EDIT!
$([ "$dev" = "true" ] && echo "// +build development")

package $name

import (
$(for module in "$@"; do echo "$module" | sed 's/\(.*\)/\t_ "\1"/'; done)
)
HERE
	${GO:-go} fmt "$path" > /dev/null
}

# create_imports takes a package name, source directory, and list of modules
# and creates release and development import files in that directory.
create_imports () {
	local name="$1"
	local dir="$2"
	shift 2

	create_import "$dir/$importfile"      "$name" "false" $(dev_modules "false" "$@")
	create_import "$dir/$developmentfile" "$name" "true"  $(dev_modules "true"  "$@")
}

for pkg in $(${GO:-go} list -f '{{.Name}}:{{.ImportPath}}:{{.Dir}}' "$@"); do
	name=$(echo "$pkg" | cut -d: -f 1)
	import=$(echo "$pkg" | cut -d: -f 2)
	dir=$(echo "$pkg" | cut -d: -f 3)

	parents=$(find_directive "$dir")
	if [ -n "$parents" ]; then
		[ "$verbose" = "false" ] || echo "$import: importing" $parents
		create_imports "$name" "$dir" $(list_modules $parents)
	fi
done
